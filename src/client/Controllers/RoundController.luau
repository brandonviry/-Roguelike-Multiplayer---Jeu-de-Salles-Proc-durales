--[[
	RoundController - Contr√¥leur des rounds
	G√®re la logique des rounds (d√©marrage, fin, musique)
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RoundController = {}

-- D√©pendances
local SoundManager = nil
local RoundUI = nil
local EndScreenUI = nil
local TimerUI = nil

local currentRoundNumber = 0
local gameMusic = nil
local timerTickSound = nil

-- Initialiser le contr√¥leur
function RoundController.initialize(deps)
	SoundManager = deps.SoundManager
	RoundUI = deps.RoundUI
	EndScreenUI = deps.EndScreenUI
	TimerUI = deps.TimerUI
end

-- G√©rer le changement d'√©tat du round
function RoundController.onRoundStateChanged(state, roundNumber, extraData)
	print("üîÑ √âtat du round chang√©:", state, "Round:", roundNumber or "N/A")

	-- Mettre √† jour l'UI
	if RoundUI then
		RoundUI.updateState(state, roundNumber, extraData)
	end

	-- Gestion de la musique et des sons
	if state == "STARTED" then
		currentRoundNumber = roundNumber

		-- Arr√™ter le son du timer si il joue encore
		if timerTickSound then
			timerTickSound:Stop()
			timerTickSound:Destroy()
			timerTickSound = nil
		end

		-- Son de d√©marrage du round
		if SoundManager then
			SoundManager.playLocalSound("RoundStart")

			-- D√©marrer la musique d'ambiance
			if not gameMusic then
				gameMusic = SoundManager.createLoopingMusic("GameMusic")
			end
			if gameMusic then
				SoundManager.fadeIn(gameMusic, 2)
			end
		end

	elseif state == "ENDED" then
		-- Fade out de la musique d'ambiance
		if SoundManager and gameMusic then
			SoundManager.fadeOut(gameMusic, 2)
		end
	end
end

-- G√©rer la fin de partie
function RoundController.onGameEnded(winnerName, leaderboard)
	print("üèÜ Fin de round! Gagnant:", winnerName)

	-- Jouer le son de victoire
	if SoundManager then
		SoundManager.playLocalSound("Victory")
	end

	-- Cr√©er l'√©cran de fin
	if EndScreenUI then
		local endScreenGui, overlay, mainFrame = EndScreenUI.show(winnerName, leaderboard)

		-- D√©marrer le son du timer (tick en boucle)
		if SoundManager then
			timerTickSound = SoundManager.createLoopingMusic("TimerTick")
			if timerTickSound then
				timerTickSound:Play()
			end
		end

		-- Cr√©er le timer sur l'√©cran de fin
		if TimerUI then
			TimerUI.create(endScreenGui, 30, function(timeLeft)
				-- Son d'alerte √† 10 secondes
				if SoundManager and timeLeft == 10 then
					SoundManager.playLocalSound("TimerWarning")
				end
			end, function()
				-- Fermer l'√©cran √† la fin du timer
				if endScreenGui and endScreenGui.Parent then
					print("üóëÔ∏è Fermeture automatique de l'√©cran de fin")
					-- Animer la fermeture
					local TweenService = game:GetService("TweenService")
					if overlay then
						TweenService:Create(overlay, TweenInfo.new(0.5), {
							BackgroundTransparency = 1
						}):Play()
					end
					if mainFrame then
						TweenService:Create(mainFrame, TweenInfo.new(0.5), {
							BackgroundTransparency = 1
						}):Play()
					end
					task.wait(0.5)
					endScreenGui:Destroy()
				end
			end)
		end
	end
end

-- Connecter aux √©v√©nements
function RoundController.connect()
	local remotesFolder = ReplicatedStorage:WaitForChild("Remotes", 10)
	if not remotesFolder then
		warn("‚ùå RoundController: Impossible de trouver le dossier Remotes!")
		return
	end

	-- √âcouter les changements d'√©tat de round
	local roundStateEvent = remotesFolder:WaitForChild("RoundStateChanged", 5)
	if roundStateEvent then
		roundStateEvent.OnClientEvent:Connect(function(state, roundNumber, extraData)
			RoundController.onRoundStateChanged(state, roundNumber, extraData)
		end)
	end

	-- √âcouter les fins de partie
	local gameEndedEvent = remotesFolder:WaitForChild("GameEnded", 5)
	if gameEndedEvent then
		gameEndedEvent.OnClientEvent:Connect(function(winnerName, leaderboard)
			RoundController.onGameEnded(winnerName, leaderboard)
		end)
	end

	print("‚úÖ RoundController connect√©")
end

return RoundController
