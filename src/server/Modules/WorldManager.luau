--[[
	WorldManager
	Orchestrateur principal du monde de jeu
	Coordonne toutes les interactions entre les modules
]]

local Players = game:GetService("Players")
local ServerConfig = require(script.Parent.Parent.Config.ServerConfig)

local WorldManager = {}

-- Initialiser le WorldManager avec toutes ses d√©pendances
function WorldManager:Init(dependencies)
	print("üåç Initialisation WorldManager...")

	-- Injecter les d√©pendances
	self.gridService = dependencies.gridService
	self.remoteService = dependencies.remoteService
	self.playerManager = dependencies.playerManager
	self.roomFactory = dependencies.roomFactory
	self.pathfindingService = dependencies.pathfindingService

	-- √âtat du jeu
	self.gameEnded = false

	print("‚úÖ WorldManager initialis√©")
	return self
end

-- T√©l√©porter un joueur vers une salle
function WorldManager:TeleportPlayerToRoom(player, x, y)
	if self.gameEnded then
		print("‚ö†Ô∏è Jeu termin√©, t√©l√©portation annul√©e")
		return
	end

	local character = player.Character
	if not character then
		warn("‚ö†Ô∏è Character introuvable pour", player.Name)
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("‚ö†Ô∏è HumanoidRootPart introuvable pour", player.Name)
		return
	end

	-- Cr√©er la salle si elle n'existe pas
	if not self.gridService:RoomExists(x, y) then
		local doorConfig = self.pathfindingService:GenerateDoorConfig(x, y)
		self.roomFactory:CreateRoom(x, y, doorConfig, function(p, tx, ty)
			self:TeleportPlayerToRoom(p, tx, ty)
		end)
	end

	-- T√©l√©porter le joueur
	local roomWorldPos = self.gridService:GridToWorld(x, y)
	hrp.CFrame = CFrame.new(roomWorldPos + Vector3.new(0, 10, 0))

	-- Mettre √† jour la position
	local hasChangedRoom = self.gridService:UpdatePlayerPosition(player.UserId, x, y)

	-- Incr√©menter le compteur de salles visit√©es
	if hasChangedRoom then
		self.playerManager:IncrementRoomsVisited(player)
	end

	print("üìç", player.Name, "t√©l√©port√© √† la salle", x, y)
end

-- Terminer la partie pour tous les joueurs
-- NOTE: Cette m√©thode est intercept√©e par le hook dans init.server.luau
-- et redirig√©e vers RoundManager:EndRound()
function WorldManager:EndGame(winner)
	print("üéØ WorldManager:EndGame appel√© (normalement intercept√© par hook)")
	print("üéØ Winner:", winner and winner.Name or "nil")

	if self.gameEnded then
		print("‚ö†Ô∏è Partie d√©j√† termin√©e")
		return
	end

	print("üèÜ === FIN DE PARTIE ===")
	print("üèÜ Gagnant:", winner.Name)

	self.gameEnded = true

	-- Le reste de la logique est g√©r√© par RoundManager via le hook
	warn("‚ö†Ô∏è WorldManager:EndGame appel√© directement sans hook! Cela ne devrait pas arriver.")
end

-- Cr√©er la zone de fin avec d√©tection de toucher
function WorldManager:SetupEndZoneDetection(endZone, x, y)
	print("üéØ Configuration d√©tection EndZone pour salle", x, y)
	print("üéØ EndZone part:", endZone:GetFullName())

	endZone.Touched:Connect(function(hit)
		print("üëÜ EndZone touch√©e par:", hit:GetFullName())

		if self.gameEnded then
			print("‚ö†Ô∏è Jeu d√©j√† termin√©, ignor√©")
			return
		end

		local character = hit.Parent
		local touchingPlayer = Players:GetPlayerFromCharacter(character)

		if touchingPlayer and character:FindFirstChild("Humanoid") then
			print("üèÜ " .. touchingPlayer.Name .. " a atteint l'arriv√©e!")
			print("üèÜ Appel de EndGame...")
			-- Le RoundManager s'occupera de la fin de partie
			self:EndGame(touchingPlayer)
		else
			print("‚ö†Ô∏è Touch non valide - pas un joueur ou pas d'humanoid")
		end
	end)

	print("‚úÖ .Touched event connect√© avec succ√®s")
end

-- R√©initialiser le monde pour un nouveau round
function WorldManager:ResetWorld()
	print("üîÑ Reset du monde...")

	-- Clear la grille
	self.gridService:ClearAllRooms()

	-- G√©n√©rer nouvelle position Z
	self.gridService:GenerateNewEndPosition()

	-- Reset le flag de fin
	self.gameEnded = false

	-- Reset les joueurs
	self.playerManager:ResetAllPlayers()

	print("‚úÖ Monde r√©initialis√©")
end

-- Cr√©er les salles de d√©part et d'arriv√©e
function WorldManager:CreateMainRooms()
	print("üèóÔ∏è Cr√©ation des salles principales...")

	local startPos = self.gridService.startPos
	local endPos = self.gridService.endPos

	-- Salle de d√©part (O)
	local startDoorConfig = self.pathfindingService:GenerateDoorConfig(startPos.x, startPos.y)
	self.roomFactory:CreateRoom(startPos.x, startPos.y, startDoorConfig, function(p, tx, ty)
		self:TeleportPlayerToRoom(p, tx, ty)
	end)

	-- Salle d'arriv√©e (Z)
	self.roomFactory:CreateRoom(endPos.x, endPos.y, {}, nil)

	-- Setup la d√©tection de fin sur la zone Z
	print("üîç Recherche de la zone de fin...")
	local endRoom = self.gridService:GetRoom(endPos.x, endPos.y)
	if endRoom and endRoom.folder then
		print("‚úÖ Dossier de salle Z trouv√©:", endRoom.folder:GetFullName())
		local endZone = endRoom.folder:FindFirstChild("EndZone")
		if endZone then
			print("‚úÖ EndZone trouv√©e! Configuration de la d√©tection...")
			self:SetupEndZoneDetection(endZone, endPos.x, endPos.y)
			print("‚úÖ D√©tection EndZone configur√©e avec succ√®s")
		else
			warn("‚ùå EndZone non trouv√©e dans le dossier!")
		end
	else
		warn("‚ùå Dossier de salle Z non trouv√©!")
	end

	print("‚úÖ Salles principales cr√©√©es")
end

-- T√©l√©porter tous les joueurs au spawn
function WorldManager:TeleportAllPlayersToStart()
	print("üöÄ T√©l√©portation de tous les joueurs au spawn...")

	task.wait(2) -- Attendre que les salles soient pr√™tes

	for _, player in ipairs(Players:GetPlayers()) do
		self:TeleportPlayerToRoom(player, self.gridService.startPos.x, self.gridService.startPos.y)
	end

	print("‚úÖ Tous les joueurs t√©l√©port√©s")
end

-- Obtenir les donn√©es de l'√©tat du jeu (pour les commandes admin)
function WorldManager:GetGameState()
	-- Cr√©er une structure compatible avec l'ancien syst√®me
	local config = {
		COIN_VALUE = ServerConfig.Gameplay.COIN_VALUE,
		ROOM_SIZE = ServerConfig.Grid.ROOM_SIZE,
		ROOM_SPACING = ServerConfig.Grid.ROOM_SPACING,
		DOOR_SIZE = ServerConfig.Gameplay.DOOR_SIZE,
		MIN_COINS_PER_ROOM = ServerConfig.Gameplay.MIN_COINS_PER_ROOM,
		MAX_COINS_PER_ROOM = ServerConfig.Gameplay.MAX_COINS_PER_ROOM,
		MIN_OBSTACLES = ServerConfig.Gameplay.MIN_OBSTACLES,
		MAX_OBSTACLES = ServerConfig.Gameplay.MAX_OBSTACLES,
		GRID_SIZE = ServerConfig.Grid.SIZE,
		MIN_PATH_LENGTH = ServerConfig.Grid.MIN_PATH_LENGTH,
	}

	return {
		CONFIG = config,
		worldGrid = self.gridService.worldGrid,
		playerPositions = self.gridService.playerPositions,
		startPos = self.gridService.startPos,
		endPos = self.gridService.endPos,
		gameEnded = self.gameEnded,
		teleportPlayerToRoom = function(player, x, y)
			self:TeleportPlayerToRoom(player, x, y)
		end,
		endGameForAll = function(winner)
			self:EndGame(winner)
		end,
		restartGame = function()
			-- Appeler le hook install√© par init.server.luau sur self
			if self.restartGame then
				self.restartGame()
			else
				warn("‚ö†Ô∏è restartGame appel√© mais pas de hook install√©!")
			end
		end,
		compassEvent = self.remoteService:Get("CompassToggle"),
	}
end

return WorldManager
