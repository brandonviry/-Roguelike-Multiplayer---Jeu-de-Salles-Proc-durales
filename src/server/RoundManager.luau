--[[
	SystÃ¨me de gestion des rounds
	GÃ¨re le cycle: Round â†’ RÃ©sultats â†’ Reset â†’ Nouveau Round
	REFACTORISÃ‰ pour utiliser WorldManager
]]

local ServerConfig = require(script.Parent.Config.ServerConfig)

local RoundManager = {}

-- Ã‰tats possibles
RoundManager.States = {
	WAITING = "WAITING",     -- Attente entre rounds (15 secondes)
	PLAYING = "PLAYING",     -- Round en cours
	ENDED = "ENDED",         -- Round terminÃ©, affichage rÃ©sultats
}

-- Ã‰tat actuel
RoundManager.currentState = RoundManager.States.WAITING
RoundManager.currentRound = 0
RoundManager.roundWinner = nil

-- DurÃ©es (en secondes)
RoundManager.WAITING_TIME = ServerConfig.Rounds.WAITING_TIME
RoundManager.RESULTS_TIME = ServerConfig.Rounds.RESULTS_TIME

-- Initialiser avec les dÃ©pendances
function RoundManager:Init(worldManager, remoteService, playerManager)
	self.worldManager = worldManager
	self.remoteService = remoteService
	self.playerManager = playerManager
	print("ğŸ® RoundManager initialisÃ©")
	return self
end

-- Commencer un nouveau round
function RoundManager:StartNewRound()
	print("ğŸ”„ === NOUVEAU ROUND ===")

	self.currentRound = self.currentRound + 1
	self.currentState = self.States.PLAYING
	self.roundWinner = nil

	-- Reset le monde via WorldManager
	self.worldManager:ResetWorld()

	-- CrÃ©er les salles principales
	self.worldManager:CreateMainRooms()

	-- TÃ©lÃ©porter tous les joueurs
	self.worldManager:TeleportAllPlayersToStart()

	-- Notifier tous les clients
	self.remoteService:FireAllClients("RoundStateChanged", "STARTED", self.currentRound)

	print("âœ… Round", self.currentRound, "commencÃ©!")
	print("ğŸ PremiÃ¨re personne Ã  atteindre Z gagne!")
end

-- Terminer le round
function RoundManager:EndRound(winner)
	print("ğŸ¯ RoundManager:EndRound appelÃ© avec winner:", winner and winner.Name or "nil")

	if self.currentState ~= self.States.PLAYING then
		print("âš ï¸ Round dÃ©jÃ  terminÃ© ou pas en cours (Ã©tat:", self.currentState, ")")
		return -- Round dÃ©jÃ  terminÃ©
	end

	print("ğŸ† === FIN DU ROUND", self.currentRound, "===")
	print("ğŸ† Gagnant:", winner.Name)

	self.currentState = self.States.ENDED
	self.roundWinner = winner

	-- Marquer le jeu comme terminÃ© dans WorldManager
	self.worldManager.gameEnded = true

	-- CrÃ©er le leaderboard via PlayerManager
	local leaderboard = self.playerManager:GetFinalLeaderboard(winner)

	print("ğŸ“Š Classement final:")
	for i, entry in ipairs(leaderboard) do
		local prefix = entry.isWinner and "ğŸ‘‘" or "  "
		print(prefix, i .. ".", entry.player.Name, "-", entry.coins, "coins,", entry.rooms, "salles")
	end

	-- Envoyer les rÃ©sultats aux clients
	self.remoteService:FireAllClients("GameEnded", winner.Name, leaderboard)

	-- Notifier le changement d'Ã©tat
	self.remoteService:FireAllClients("RoundStateChanged", "ENDED", self.currentRound, winner.Name)

	-- Attendre avant de commencer le prochain round
	print("â³ Prochain round dans", self.WAITING_TIME, "secondes...")

	task.wait(self.RESULTS_TIME)

	-- Ã‰tat d'attente
	self.currentState = self.States.WAITING
	self.remoteService:FireAllClients("RoundStateChanged", "WAITING", self.WAITING_TIME)

	-- Compte Ã  rebours
	for i = self.WAITING_TIME, 1, -1 do
		print("â±ï¸", i, "secondes avant le prochain round...")
		task.wait(1)
	end

	-- DÃ©marrer le nouveau round
	self:StartNewRound()
end

-- DÃ©marrer le systÃ¨me de rounds
function RoundManager:Start()
	print("ğŸ® DÃ©marrage du systÃ¨me de rounds...")

	-- Attendre quelques secondes pour que les joueurs se connectent
	print("â³ DÃ©marrage dans", ServerConfig.Rounds.START_DELAY, "secondes...")
	task.wait(ServerConfig.Rounds.START_DELAY)

	-- DÃ©marrer le premier round
	self:StartNewRound()
end

return RoundManager
